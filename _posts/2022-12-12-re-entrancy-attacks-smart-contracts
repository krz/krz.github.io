I've been playing around with smart contracts recently. In this post I explain a re-entrancy attacks, a common security flaw in many smart contracts Re-entrancy attacks occur when a smart contract function temporarily abandons the transaction's control flow by making an external call to a contract written by unknown or hostile actors. This allows the latter contract to make a recursive call to the primary smart contract function to drain its funds.

The steps in this attack are as follows:

1. The attacker requests the vulnerable Contract **X** to transfer funds to the malicious Contract **Y**.
2. Contract **X** determines if the attacker has the required funds, and then transfers the funds to Contract **Y**.
3. The attacker then executes a callback function. Once Contract **Y** receives the funds, it executes a callback function that calls Contract **X** back before updating the account balance.
4. This recursive process continues until all funds are used up and transferred.

Re-entrancy attacks are best illustrated by an example. Consider this simple Bank contract called **EOABank**:

```solidity
//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.9;

contract EOABank {

    mapping(address => uint) public balances;

    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }

    function withdrawAll() public {
        (bool success, ) = msg.sender.call{ value: balances[msg.sender] }("");
        require(success, "Transaction failed!");
        balances[msg.sender] = 0;
    }
}
```

What this contract does is simple. It accepts payments through the `deposit()` function and allows withdrawal of all funds with the `withdrawAll()` function.
